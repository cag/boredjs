{"version":3,"sources":["../../lib/check-dependencies.js"],"names":[],"mappings":"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","file":"check-dependencies.js","sourcesContent":["'use strict';\n\n/* eslint-disable no-undef */\n\nconst fs = require('fs');\nconst path = require('path');\nconst chalk = require('chalk');\nconst findup = require('findup-sync');\nconst _ = require('lodash');\nconst semver = require('semver');\nconst spawn = require('child_process').spawn;\nconst spawnSync = require('child_process').spawnSync;\n\n/* eslint-enable no-undef */\n\nconst checkDependenciesHelper = (syncOrAsync, config, callback) => {\n    // We treat the signature:\n    //     checkDependencies(callback)\n    // as:\n    //     checkDependencies({}, callback)\n\n    if (syncOrAsync === 'async') {\n        // Catch all cases where `config` is not an object - even if it's not a function\n        // so it's useless here, we need it to be assigned to `callback` to provide\n        // to the error message.\n        if (typeof callback !== 'function' && (typeof config !== 'object' || config == null)) {\n            callback = config;\n            config = null;\n        }\n        if (typeof callback !== 'function') {\n            if (callback == null) {\n                // In the async mode we return the promise anyway; assign callback\n                // to noop to keep code consistency.\n                callback = _.noop;\n            } else {\n                // If callback was simply not provided, we assume the user wanted\n                // to handle the returned promise. If it was passed but not a function\n                // we assume user error and throw.\n                throw new Error('The provided callback wasn\\'t a function! Got:', callback);\n            }\n        }\n    }\n\n    const win32 = process.platform === 'win32';\n    const output = {log: [], error: []};\n\n    let depsDirName, packageJson, pkgManagerPath;\n\n    let installPrunePromise = Promise.resolve();\n    let success = true;\n    let installNeeded = false;\n    let pruneNeeded = false;\n\n    const options = _.defaults({}, config, {\n        packageManager: 'npm',\n        onlySpecified: false,\n        install: false,\n        scopeList: ['dependencies', 'devDependencies'],\n        optionalScopeList: ['optionalDependencies'],\n        verbose: false,\n        checkGitUrls: false,\n        checkCustomPackageNames: false,\n        log: console.log.bind(console),\n        error: console.error.bind(console),\n    });\n\n    const packageJsonName = options.packageManager === 'npm' ? 'package.json' : 'bower.json';\n    const packageJsonRegex = options.packageManager === 'npm' ? /package\\.json$/ : /bower\\.json$/;\n    depsDirName = options.packageManager === 'npm' ? 'node_modules' : 'bower_components';\n\n    const log = message => {\n        output.log.push(message);\n        if (options.verbose) {\n            options.log(message);\n        }\n    };\n\n    const error = message => {\n        output.error.push(message);\n        if (options.verbose) {\n            options.error(message);\n        }\n    };\n\n    const finish = () => {\n        output.status = success ? 0 : 1;\n        if (syncOrAsync === 'async') {\n            callback(output);\n            return new Promise(resolve => resolve(output));\n        }\n        return output;\n    };\n\n    const missingPackageJson = () => {\n        success = false;\n        error(`Missing ${ packageJsonName }!`);\n        return finish();\n    };\n\n    options.packageDir = options.packageDir || findup(packageJsonName);\n    if (!options.packageDir) {\n        return missingPackageJson();\n    }\n    options.packageDir = path.resolve(options.packageDir.replace(packageJsonRegex, ''));\n\n    packageJson = `${ options.packageDir }/${ packageJsonName }`;\n    if (!fs.existsSync(packageJson)) {\n        return missingPackageJson();\n    }\n    packageJson = require(packageJson);\n\n    if (options.packageManager === 'bower') {\n        const bowerConfig = require('bower-config').create(options.packageDir).load();\n        depsDirName = bowerConfig._config.directory;\n    }\n\n    // Bower uses a different name (with a dot) for package data of dependencies.\n    const depsJsonName = options.packageManager === 'npm' ? 'package.json' : '.bower.json';\n\n    if (options.packageManager === 'bower') {\n        // Allow a local bower.\n        pkgManagerPath = findup('node_modules/bower/bin/bower');\n    }\n\n    const depsDir = `${ options.packageDir }/${ depsDirName }`;\n\n    const getDepsMappingsFromScopeList = scopeList =>\n        // Get names of all packages specified in package.json/bower.json at keys from scopeList\n        // together with specified version numbers.\n        scopeList.reduce((result, scope) => _.merge(result, packageJson[scope] || {}), {});\n\n    // Make sure each package from `scopeList` is present and matches the specified version range.\n    // Packages from `optionalScopeList` may not be present but if they are, they are required\n    // to match the specified version range.\n    const checkPackage = (name, versionString, isOptional) => {\n        const depDir = `${ depsDir }/${ name }`;\n        const depJson = `${ depDir }/${ depsJsonName }`;\n\n        if (!fs.existsSync(depDir) || !fs.existsSync(depJson)) {\n            if (isOptional) {\n                log(`${ name }: ${ chalk.red('not installed!') }`);\n            } else {\n                error(`${ name }: ${ chalk.red('not installed!') }`);\n                success = false;\n            }\n            return;\n        }\n\n        // Let's look if we can get a valid version from a Git URL\n        if (options.checkGitUrls && /\\.git.*\\#v?(.+)$/.test(versionString)) {\n            versionString = (/\\#v?(.+)$/.exec(versionString))[1];\n            if (!semver.valid(versionString)) {\n                return;\n            }\n        }\n\n        // Quick and dirty check - make sure we're not dealing with a URL\n        if (/\\//.test(versionString)) {\n            return;\n        }\n\n        // Bower has the option to specify a custom name, e.g. 'packageOld' : 'package#1.2.3'\n        if (options.checkCustomPackageNames && options.packageManager !== 'npm') {\n            // Let's look if we can get a valid version from a custom package name (with a # in it)\n            if (/\\.*\\#v?(.+)$/.test(versionString)) {\n                versionString = (/\\#v?(.+)$/.exec(versionString))[1];\n                if (!semver.valid(versionString)) {\n                    return;\n                }\n            }\n        }\n\n        // If we are dealing with a custom package name, semver check won't work - skip it\n        if (/\\#/.test(versionString)) {\n            return;\n        }\n\n        // Skip version checks for 'latest' - the semver module won't help here and the check\n        // would have to consult the npm server, making the operation slow.\n        if (versionString === 'latest') {\n            return;\n        }\n\n        const depVersion = require(depJson).version;\n        if (semver.satisfies(depVersion, versionString)) {\n            log(`${ name }: installed: ${ chalk.green(depVersion)\n                }, expected: ${ chalk.green(versionString) }`);\n        } else {\n            success = false;\n            error(`${ name }: installed: ${ chalk.red(depVersion)\n                }, expected: ${ chalk.green(versionString) }`);\n        }\n    };\n\n    const depsMappings = getDepsMappingsFromScopeList(options.scopeList);\n    const optionalDepsMappings = getDepsMappingsFromScopeList(options.optionalScopeList);\n    const fullDepsMappings = _.assign({}, depsMappings, optionalDepsMappings);\n\n    _.forEach(depsMappings, (versionString, name) => {\n        checkPackage(name, versionString, false /* isOptional */);\n    });\n\n    _.forEach(optionalDepsMappings, (versionString, name) => {\n        checkPackage(name, versionString, true /* isOptional */);\n    });\n\n    installNeeded = !success;\n\n    if (options.onlySpecified) {\n        fs\n            .readdirSync(depsDir)\n\n            // Ignore hidden directories\n            .filter(depName => depName[0] !== '.')\n\n            // Ignore files\n            .filter(depName => fs.lstatSync(`${ depsDir }/${ depName }`).isDirectory())\n\n            .forEach(depName => {\n                let depSubDirName;\n\n                // Scoped packages\n                if (depName[0] === '@') {\n                    depName = fs.readdirSync(`${ depsDir }/${ depName }`)[0];\n\n                    // Ignore weird directories - if it just looks like a scoped package but\n                    // isn't one, just skip it.\n                    if (depSubDirName && !fullDepsMappings[depName]) {\n                        success = false;\n                        pruneNeeded = true;\n                        error(`Package ${ depName } installed, though it shouldn\\'t be`);\n                    }\n                    return;\n                }\n\n                // Regular packages\n                if (!fullDepsMappings[depName]) {\n                    success = false;\n                    pruneNeeded = true;\n                    error(`Package ${ depName } installed, though it shouldn\\'t be`);\n                }\n            });\n    }\n\n    if (success) {\n        output.depsWereOk = true;\n        return finish();\n    }\n    output.depsWereOk = false;\n\n    if (!options.install) {\n        if (options.onlySpecified) {\n            error(`Invoke ${ chalk.green(`${ options.packageManager } prune`) } and ${\n                chalk.green(`${ options.packageManager } install`)\n                } to install missing packages and remove excessive ones`);\n        } else {\n            error(`Invoke ${ chalk.green(`${ options.packageManager } install`)\n                } to install missing packages`);\n        }\n        return finish();\n    }\n\n\n    const installOrPrune = mode => {\n        log(`Invoking ${ chalk.green(`${ options.packageManager } ${ mode }`) }...`);\n\n        // If we're using a direct path, on Windows we need to invoke it via `node path`, not\n        // `cmd /c path`. In UNIX systems we can execute the command directly so no need to wrap.\n        let msg, spawnReturn;\n        const method = syncOrAsync === 'sync' ? spawnSync : spawn;\n\n        if (win32) {\n            spawnReturn = method(pkgManagerPath ? 'node' : 'cmd',\n                (pkgManagerPath ? [pkgManagerPath] : ['/c', options.packageManager]).concat([mode]),\n                {\n                    cwd: options.packageDir,\n                    stdio: 'inherit',\n                });\n        } else {\n            spawnReturn = method(options.packageManager,\n                [mode],\n                {\n                    cwd: options.packageDir,\n                    stdio: 'inherit',\n                });\n        }\n\n        if (syncOrAsync === 'sync') {\n            if (spawnReturn.status !== 0) {\n                msg = `${ options.packageManager } ${ mode } failed with code: ${\n                    chalk.red(spawnReturn.status) }`;\n                throw new Error(msg);\n            }\n            return null;\n        }\n        return new Promise((resolve, reject) => {\n            spawnReturn.on('close', code => {\n                if (code === 0) {\n                    resolve();\n                    return;\n                }\n                msg = `${ options.packageManager } ${ mode } failed with code: ${\n                    chalk.red(code) }`;\n                error(msg);\n                reject(msg);\n            });\n        });\n    };\n\n    const installMissing = () => installOrPrune('install');\n    const pruneExcessive = () => installOrPrune('prune');\n\n    if (syncOrAsync === 'sync') {\n        try {\n            if (installNeeded) {\n                installMissing();\n            }\n\n            if (pruneNeeded) {\n                pruneExcessive();\n            }\n\n            success = true;\n        } catch (error) {\n            success = false;\n        }\n        return finish();\n    }\n\n    // Async scenario\n    if (installNeeded) {\n        installPrunePromise = installPrunePromise.then(installMissing);\n    }\n\n    if (pruneNeeded) {\n        installPrunePromise = installPrunePromise.then(pruneExcessive);\n    }\n\n    return installPrunePromise\n        .then(() => {\n            success = true;\n            return finish();\n        })\n        .catch(() => {\n            success = false;\n            return finish();\n        });\n};\n\nmodule.exports = function checkDependencies(/* config, callback */) {\n    const args = Array.prototype.slice.call(arguments);\n    args.unshift('async');\n    return checkDependenciesHelper(...args);\n};\n\nmodule.exports.sync = function checkDependenciesSync(/* config */) {\n    if (!spawnSync) {\n        throw new Error([\n            'Your version of Node.js doesn\\'t support child_process.spawnSync.',\n            'Update Node.js or use require(\\'checkDependencies\\') instead of',\n            'require(\\'checkDependencies\\').sync.',\n        ].join(' '));\n    }\n    const args = Array.prototype.slice.call(arguments);\n    args.unshift('sync');\n    return checkDependenciesHelper(...args);\n};\n"]}